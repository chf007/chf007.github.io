<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>怒涛小站 | chf007 的自留地</title>

  
  <meta name="author" content="chf007">
  

  
  <meta name="description" content="Fullstack Developer">
  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="怒涛小站"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="怒涛小站" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 5.0.2"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">怒涛小站</a>
    </h1>
    <p class="site-description">chf007 的自留地</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/tags">标签</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/about">关于</a></li>
      
        <li><a href="/atom.xml">订阅</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2021/12/03/rust-references-and-borrowing/"><span>Rust 引用与借用</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/12/03/rust-references-and-borrowing/" rel="bookmark">
        <time class="entry-date published" datetime="2021-12-03T08:51:55.000Z">
          2021-12-03
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="引用与借用"><a href="#引用与借用" class="headerlink" title="引用与借用"></a>引用与借用</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/rust-lang/book/blob/main/src/ch04-02-references-and-borrowing.md">ch04-02-references-and-borrowing.md</a><br><br><br>commit d377d2effa9ae9173026e35a7e464b8f5b82409a</p>
</blockquote>
<p>示例 4-5 中的元组代码有这样一个问题：我们必须将 <code>String</code> 返回给调用函数，以便在调用 <code>calculate_length</code> 后仍能使用 <code>String</code>，因为 <code>String</code> 被移动到了 <code>calculate_length</code> 内。</p>
<p>下面是如何定义并使用一个（新的）<code>calculate_length</code> 函数，它以一个对象的引用作为参数而不是获取值的所有权：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> len = calculate_length(&amp;s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    s.len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，注意变量声明和函数返回值中的所有元组代码都消失了。其次，注意我们传递 <code>&amp;s1</code> 给 <code>calculate_length</code>，同时在函数定义中，我们获取 <code>&amp;String</code> 而不是 <code>String</code>。</p>
<p>这些 &amp; 符号就是 <strong>引用</strong>，它们允许你使用值但不获取其所有权。图 4-5 展示了一张示意图。</p>
<img alt="&String s pointing at String s1" src="img/trpl04-05.svg" class="center" />

<p><span class="caption">图 4-5：<code>&amp;String s</code> 指向 <code>String s1</code> 示意图</span></p>
<blockquote>
<p>注意：与使用 <code>&amp;</code> 引用相反的操作是 <strong>解引用</strong>（<em>dereferencing</em>），它使用解引用运算符，<code>*</code>。我们将会在第八章遇到一些解引用运算符，并在第十五章详细讨论解引用。</p>
</blockquote>
<p>仔细看看这个函数调用：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># <span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">#     s.len()</span><br><span class="line"># &#125;</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> len = calculate_length(&amp;s1);</span><br></pre></td></tr></table></figure>

<p><code>&amp;s1</code> 语法让我们创建一个 <strong>指向</strong> 值 <code>s1</code> 的引用，但是并不拥有它。因为并不拥有这个值，所以当引用停止使用时，它所指向的值也不会被丢弃。</p>
<p>同理，函数签名使用 <code>&amp;</code> 来表明参数 <code>s</code> 的类型是一个引用。让我们增加一些解释性的注释：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123; <span class="comment">// s 是对 String 的引用</span></span><br><span class="line">    s.len()</span><br><span class="line">&#125; <span class="comment">// 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，</span></span><br><span class="line">  <span class="comment">// 所以什么也不会发生</span></span><br></pre></td></tr></table></figure>

<p>变量 <code>s</code> 有效的作用域与函数参数的作用域一样，不过当引用停止使用时并不丢弃它指向的数据，因为我们没有所有权。当函数使用引用而不是实际值作为参数，无需返回值来交还所有权，因为就不曾拥有所有权。</p>
<p>我们将创建一个引用的行为称为 <strong>借用</strong>（<em>borrowing</em>）。正如现实生活中，如果一个人拥有某样东西，你可以从他那里借来。当你使用完毕，必须还回去。</p>
<p>如果我们尝试修改借用的变量呢？尝试示例 4-6 中的代码。剧透：这行不通！</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let s &#x3D; String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">    change(&amp;s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn change(some_string: &amp;String) &#123;</span><br><span class="line">    some_string.push_str(&quot;, world&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><span class="caption">示例 4-6：尝试修改借用的值</span></p>
<p>这里是错误：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">error[E0596]: cannot borrow immutable borrowed content `*some_string` as mutable</span><br><span class="line"><span class="meta"> --&gt;</span><span class="bash"> error.rs:8:5</span></span><br><span class="line">  |</span><br><span class="line">7 | fn change(some_string: &amp;String) &#123;</span><br><span class="line">  |                        ------- use `&amp;mut String` here to make mutable</span><br><span class="line">8 |     some_string.push_str(&quot;, world&quot;);</span><br><span class="line">  |     ^^^^^^^^^^^ cannot borrow as mutable</span><br></pre></td></tr></table></figure>

<p>正如变量默认是不可变的，引用也一样。（默认）不允许修改引用的值。</p>
<h3 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a>可变引用</h3><p>我们通过一个小调整就能修复示例 4-6 代码中的错误：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    change(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">change</span></span>(some_string: &amp;<span class="keyword">mut</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">    some_string.push_str(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，我们必须将 <code>s</code> 改为 <code>mut</code>。然后必须在调用 <code>change</code> 函数的地方创建一个可变引用 <code>&amp;mut s</code>，并更新函数签名以接受一个可变引用 <code>some_string: &amp;mut String</code>。这就非常清楚地表明，<code>change</code> 函数将改变它所借用的值。</p>
<p>不过可变引用有一个很大的限制：在同一时间只能有一个对某一特定数据的可变引用。这些代码会失败：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let mut s &#x3D; String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">let r1 &#x3D; &amp;mut s;</span><br><span class="line">let r2 &#x3D; &amp;mut s;</span><br><span class="line"></span><br><span class="line">println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2);</span><br></pre></td></tr></table></figure>


<p>错误如下：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cargo run</span></span><br><span class="line">   Compiling ownership v0.1.0 (file:///projects/ownership)</span><br><span class="line">error[E0499]: cannot borrow `s` as mutable more than once at a time</span><br><span class="line"><span class="meta"> --&gt;</span><span class="bash"> src/main.rs:5:14</span></span><br><span class="line">  |</span><br><span class="line">4 |     let r1 = &amp;mut s;</span><br><span class="line">  |              ------ first mutable borrow occurs here</span><br><span class="line">5 |     let r2 = &amp;mut s;</span><br><span class="line">  |              ^^^^^^ second mutable borrow occurs here</span><br><span class="line">6 |</span><br><span class="line">7 |     println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2);</span><br><span class="line">  |                        -- first borrow later used here</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0499`.</span><br><span class="line">error: could not compile `ownership` due to previous error</span><br></pre></td></tr></table></figure>

<p>这个报错说这段代码是无效的，因为我们不能在同一时间多次将 <code>s</code> 作为可变变量借用。第一个可变的借入在 <code>r1</code> 中，并且必须持续到在 <code>println！</code> 中使用它，但是在那个可变引用的创建和它的使用之间，我们又尝试在 <code>r2</code> 中创建另一个可变引用，该引用借用与 <code>r1</code> 相同的数据。<br>防止同一时间对同一数据进行多个可变引用的限制允许可变性，不过是以一种受限制的方式允许。新 Rustacean 们经常难以适应这一点，因为大部分语言中变量任何时候都是可变的。</p>
<p>这个限制的好处是 Rust 可以在编译时就避免数据竞争。<strong>数据竞争</strong>（<em>data race</em>）类似于竞态条件，它可由这三个行为造成：</p>
<ul>
<li>两个或更多指针同时访问同一数据。</li>
<li>至少有一个指针被用来写入数据。</li>
<li>没有同步数据访问的机制。</li>
</ul>
<p>数据竞争会导致未定义行为，难以在运行时追踪，并且难以诊断和修复；Rust 避免了这种情况的发生，因为它甚至不会编译存在数据竞争的代码！</p>
<p>一如既往，可以使用大括号来创建一个新的作用域，以允许拥有多个可变引用，只是不能 <strong>同时</strong> 拥有：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> r1 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// r1 在这里离开了作用域，所以我们完全可以创建一个新的引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> s;</span><br></pre></td></tr></table></figure>

<p>类似的规则也存在于同时使用可变与不可变引用中。这些代码会导致一个错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let mut s &#x3D; String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">let r1 &#x3D; &amp;s; &#x2F;&#x2F; 没问题</span><br><span class="line">let r2 &#x3D; &amp;s; &#x2F;&#x2F; 没问题</span><br><span class="line">let r3 &#x3D; &amp;mut s; &#x2F;&#x2F; 大问题</span><br><span class="line"></span><br><span class="line">println!(&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;, r1, r2, r3);</span><br></pre></td></tr></table></figure>

<p>错误如下：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cargo run</span></span><br><span class="line">   Compiling ownership v0.1.0 (file:///projects/ownership)</span><br><span class="line">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable</span><br><span class="line"><span class="meta"> --&gt;</span><span class="bash"> src/main.rs:6:14</span></span><br><span class="line">  |</span><br><span class="line">4 |     let r1 = &amp;s; // no problem</span><br><span class="line">  |              -- immutable borrow occurs here</span><br><span class="line">5 |     let r2 = &amp;s; // no problem</span><br><span class="line">6 |     let r3 = &amp;mut s; // BIG PROBLEM</span><br><span class="line">  |              ^^^^^^ mutable borrow occurs here</span><br><span class="line">7 |</span><br><span class="line">8 |     println!(&quot;&#123;&#125;, &#123;&#125;, and &#123;&#125;&quot;, r1, r2, r3);</span><br><span class="line">  |                                -- immutable borrow later used here</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0502`.</span><br><span class="line">error: could not compile `ownership` due to previous error</span><br></pre></td></tr></table></figure>

<p>哇哦！我们 <strong>也</strong> 不能在拥有不可变引用的同时拥有可变引用。不可变引用的用户可不希望在他们的眼皮底下值就被意外的改变了！然而，多个不可变引用是可以的，因为没有哪个只能读取数据的人有能力影响其他人读取到的数据。</p>
<p>注意一个引用的作用域从声明的地方开始一直持续到最后一次使用为止。例如，因为最后一次使用不可变引用（<code>println!</code>)，发生在声明可变引用之前，所以如下代码是可以编译的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let mut s &#x3D; String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">let r1 &#x3D; &amp;s; &#x2F;&#x2F; 没问题</span><br><span class="line">let r2 &#x3D; &amp;s; &#x2F;&#x2F; 没问题</span><br><span class="line">println!(&quot;&#123;&#125; and &#123;&#125;&quot;, r1, r2);</span><br><span class="line">&#x2F;&#x2F; 此位置之后 r1 和 r2 不再使用</span><br><span class="line"></span><br><span class="line">let r3 &#x3D; &amp;mut s; &#x2F;&#x2F; 没问题</span><br><span class="line">println!(&quot;&#123;&#125;&quot;, r3);</span><br></pre></td></tr></table></figure>

<p>不可变引用 <code>r1</code> 和 <code>r2</code> 的作用域在 <code>println!</code> 最后一次使用之后结束，这也是创建可变引用 <code>r3</code> 的地方。它们的作用域没有重叠，所以代码是可以编译的。编译器在作用域结束之前判断不再使用的引用的能力被称为非词法作用域生命周期（Non-Lexical Lifetimes，简称NLL）。你可以在 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/non-lexical-lifetimes.html">The Edition Guide</a> 中阅读更多关于它的信息。</p>
<p>尽管这些错误有时使人沮丧，但请牢记这是 Rust 编译器在提前指出一个潜在的 bug（在编译时而不是在运行时）并精准显示问题所在。这样你就不必去跟踪为何数据并不是你想象中的那样。</p>
<h3 id="悬垂引用（Dangling-References）"><a href="#悬垂引用（Dangling-References）" class="headerlink" title="悬垂引用（Dangling References）"></a>悬垂引用（Dangling References）</h3><p>在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误地生成一个 <strong>悬垂指针</strong>（<em>dangling pointer</em>），所谓悬垂指针是其指向的内存可能已经被分配给其它持有者。相比之下，在 Rust 中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。</p>
<p>让我们尝试创建一个悬垂引用，Rust 会通过一个编译时错误来避免：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let reference_to_nothing &#x3D; dangle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn dangle() -&gt; &amp;String &#123;</span><br><span class="line">    let s &#x3D; String::from(&quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">    &amp;s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是错误：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">error[E0106]: missing lifetime specifier</span><br><span class="line"><span class="meta"> --&gt;</span><span class="bash"> main.rs:5:16</span></span><br><span class="line">  |</span><br><span class="line">5 | fn dangle() -&gt; &amp;String &#123;</span><br><span class="line">  |                ^ expected lifetime parameter</span><br><span class="line">  |</span><br><span class="line">  = help: this function&#x27;s return type contains a borrowed value, but there is</span><br><span class="line">  no value for it to be borrowed from</span><br><span class="line">  = help: consider giving it a &#x27;static lifetime</span><br></pre></td></tr></table></figure>

<p>错误信息引用了一个我们还未介绍的功能：生命周期（lifetimes）。第十章会详细介绍生命周期。不过，如果你不理会生命周期部分，错误信息中确实包含了为什么这段代码有问题的关键信息：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this function&#x27;s return type contains a borrowed value, but there is no value for it to be borrowed from.</span><br></pre></td></tr></table></figure>

<p>让我们仔细看看我们的 <code>dangle</code> 代码的每一步到底发生了什么：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fn dangle() -&gt; &amp;String &#123; &#x2F;&#x2F; dangle 返回一个字符串的引用</span><br><span class="line"></span><br><span class="line">    let s &#x3D; String::from(&quot;hello&quot;); &#x2F;&#x2F; s 是一个新字符串</span><br><span class="line"></span><br><span class="line">    &amp;s &#x2F;&#x2F; 返回字符串 s 的引用</span><br><span class="line">&#125; &#x2F;&#x2F; 这里 s 离开作用域并被丢弃。其内存被释放。</span><br><span class="line">  &#x2F;&#x2F; 危险！</span><br></pre></td></tr></table></figure>

<p>因为 <code>s</code> 是在 <code>dangle</code> 函数内创建的，当 <code>dangle</code> 的代码执行完毕后，<code>s</code> 将被释放。不过我们尝试返回它的引用。这意味着这个引用会指向一个无效的 <code>String</code>，这可不对！Rust 不会允许我们这么做。</p>
<p>这里的解决方法是直接返回 <code>String</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">no_dangle</span></span>() -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就没有任何错误了。所有权被移动出去，所以没有值被释放。</p>
<h3 id="引用的规则"><a href="#引用的规则" class="headerlink" title="引用的规则"></a>引用的规则</h3><p>让我们概括一下之前对引用的讨论：</p>
<ul>
<li>在任意给定时间，<strong>要么</strong> 只能有一个可变引用，<strong>要么</strong> 只能有多个不可变引用。</li>
<li>引用必须总是有效的。</li>
</ul>
<p>接下来，我们来看看另一种不同类型的引用：slice。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Rust/">Rust</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2021/12/03/rust-variables-and-mutability/"><span>Rust 变量和可变性</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2021/12/03/rust-variables-and-mutability/" rel="bookmark">
        <time class="entry-date published" datetime="2021-12-03T08:51:16.000Z">
          2021-12-03
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="变量和可变性"><a href="#变量和可变性" class="headerlink" title="变量和可变性"></a>变量和可变性</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/rust-lang/book/blob/main/src/ch03-01-variables-and-mutability.md">ch03-01-variables-and-mutability.md</a><br><br><br>commit 05d9c4c2312a6542f792492d17a62f79ad6dfd7b</p>
</blockquote>
<p>正如第二章中<a href="ch02-00-guessing-game-tutorial.html#%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F%E5%82%A8%E5%AD%98%E5%80%BC">“使用变量储存值”</a><!-- ignore --> 部分提到的那样，变量默认是不可改变的（immutable）。这是 Rust 提供给你的众多优势之一，让你得以充分利用 Rust 提供的安全性和简单并发性来编写代码。不过，你仍然可以使用可变变量。让我们探讨一下 Rust 为何及如何鼓励你利用不可变性，以及何时你会选择不使用不可变性。</p>
<p>当变量不可变时，一旦值被绑定一个名称上，你就不能改变这个值。为了对此进行说明，使用 <code>cargo new variables</code> 命令在 <em>projects</em> 目录生成一个叫做 <em>variables</em> 的新项目。</p>
<p>接着，在新建的 <em>variables</em> 目录，打开 <em>src/main.rs</em> 并将代码替换为如下代码，这些代码还不能编译：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fn main() &#123;</span><br><span class="line">    let x &#x3D; 5;</span><br><span class="line">    println!(&quot;The value of x is: &#123;&#125;&quot;, x);</span><br><span class="line">    x &#x3D; 6;</span><br><span class="line">    println!(&quot;The value of x is: &#123;&#125;&quot;, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存并使用 <code>cargo run</code> 运行程序。应该会看到一条错误信息，如下输出所示：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cargo run</span></span><br><span class="line">   Compiling variables v0.1.0 (file:///projects/variables)</span><br><span class="line">error[E0384]: cannot assign twice to immutable variable `x`</span><br><span class="line"><span class="meta"> --&gt;</span><span class="bash"> src/main.rs:4:5</span></span><br><span class="line">  |</span><br><span class="line">2 |     let x = 5;</span><br><span class="line">  |         -</span><br><span class="line">  |         |</span><br><span class="line">  |         first assignment to `x`</span><br><span class="line">  |         help: consider making this binding mutable: `mut x`</span><br><span class="line">3 |     println!(&quot;The value of x is: &#123;&#125;&quot;, x);</span><br><span class="line">4 |     x = 6;</span><br><span class="line">  |     ^^^^^ cannot assign twice to immutable variable</span><br><span class="line"></span><br><span class="line">error: aborting due to previous error</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0384`.</span><br><span class="line">error: could not compile `variables`</span><br><span class="line"></span><br><span class="line">To learn more, run the command again with --verbose.</span><br></pre></td></tr></table></figure>

<p>这个例子展示了编译器如何帮助你找出程序中的错误。虽然编译错误令人沮丧，但那只是表示程序不能安全的完成你想让它完成的工作；并 <strong>不能</strong> 说明你不是一个好程序员！经验丰富的 Rustacean 们一样会遇到编译错误。</p>
<p>错误信息指出错误的原因是 <code>不能对不可变变量 x 二次赋值</code>（<code>cannot assign twice to immutable variable `x` </code>），因为你尝试对不可变变量 <code>x</code> 赋第二个值。</p>
<p>在尝试改变预设为不可变的值时，产生编译时错误是很重要的，因为这种情况可能导致 bug。如果一部分代码假设一个值永远也不会改变，而另一部分代码改变了这个值，第一部分代码就有可能以不可预料的方式运行。不得不承认这种 bug 的起因难以跟踪，尤其是第二部分代码只是 <strong>有时</strong> 会改变值。</p>
<p>Rust 编译器保证，如果声明一个值不会变，它就真的不会变。这意味着当阅读和编写代码时，不需要追踪一个值如何和在哪可能会被改变，从而使得代码易于推导。</p>
<p>不过可变性也是非常有用的。变量只是默认不可变；正如在第二章所做的那样，你可以在变量名之前加 <code>mut</code> 来使其可变。除了允许改变值之外，<code>mut</code> 向读者表明了其他代码将会改变这个变量值的意图。</p>
<p>例如，让我们将 <em>src/main.rs</em> 修改为如下代码：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">    x = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在运行这个程序，出现如下内容：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cargo run</span></span><br><span class="line">   Compiling variables v0.1.0 (file:///projects/variables)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.30s</span><br><span class="line">     Running `target/debug/variables`</span><br><span class="line">The value of x is: 5</span><br><span class="line">The value of x is: 6</span><br></pre></td></tr></table></figure>

<p>通过 <code>mut</code>，允许把绑定到 <code>x</code> 的值从 <code>5</code> 改成 <code>6</code>。在一些情况下，你会想用可变变量，因为与只用不可变变量相比，它会让代码更容易编写。</p>
<p>除了防止出现 bug 外，还有很多地方需要权衡取舍。例如，使用大型数据结构时，适当地使用可变变量，可能比复制和返回新分配的实例更快。对于较小的数据结构，总是创建新实例，采用更偏向函数式的编程风格，可能会使代码更易理解，为可读性而牺牲性能或许是值得的。</p>
<h3 id="变量和常量的区别"><a href="#变量和常量的区别" class="headerlink" title="变量和常量的区别"></a>变量和常量的区别</h3><p>不允许改变值的变量，可能会使你想起另一个大部分编程语言都有的概念：<strong>常量</strong>（<em>constants</em>）。类似于不可变变量，常量是绑定到一个名称的不允许改变的值，不过常量与变量还是有一些区别。</p>
<p>首先，不允许对常量使用 <code>mut</code>。常量不光默认不能变，它总是不能变。</p>
<p>声明常量使用 <code>const</code> 关键字而不是 <code>let</code>，并且 <em>必须</em> 注明值的类型。在下一部分，<a href="ch03-02-data-types.html#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">“数据类型”</a> 中会介绍类型和类型注解，现在无需关心这些细节，记住总是标注类型即可。</p>
<p>常量可以在任何作用域中声明，包括全局作用域，这在一个值需要被很多部分的代码用到时很有用。</p>
<p>最后一个区别是，常量只能被设置为常量表达式，而不可以是其他任何只能在运行时计算出的值。</p>
<p>下面是一个声明常量的例子，常量的名称是 <code>THREE_HOURS_IN_SECONDS</code>，它的值被设置为 60（一分钟内的秒数）乘以 60（一小时内的分钟数）再乘以 3（我们在这个程序中要计算的小时数）的结果：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> THREE_HOURS_IN_SECONDS: <span class="built_in">u32</span> = <span class="number">60</span> * <span class="number">60</span> * <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>Rust 对常量的命名约定是在单词之间使用全大写加下划线。编译器能够在编译时计算一组有限的操作，这使我们可以选择以更容易理解和验证的方式写出此值，而不是将此常量设置为值10,800。有关声明常量时可以使用哪些操作的详细信息，请参阅 <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/reference/const_eval.html">Rust Reference 的常量求值部分</a>。</p>
<p>在声明它的作用域之中，常量在整个程序生命周期中都有效，此属性使得常量可以作为多处代码使用的全局范围的值，例如一个游戏中所有玩家可以获取的最高分或者光速。</p>
<p>将遍布于应用程序中的硬编码值声明为常量，能帮助后来的代码维护人员了解值的意图。如果将来需要修改硬编码值，也只需修改汇聚于一处的硬编码值。</p>
<h3 id="隐藏（Shadowing）"><a href="#隐藏（Shadowing）" class="headerlink" title="隐藏（Shadowing）"></a>隐藏（Shadowing）</h3><p>正如在第二章猜猜看游戏的 <a href="ch02-00-guessing-game-tutorial.html#%E6%AF%94%E8%BE%83%E7%8C%9C%E6%B5%8B%E7%9A%84%E6%95%B0%E5%AD%97%E5%92%8C%E7%A7%98%E5%AF%86%E6%95%B0%E5%AD%97">“比较猜测的数字和秘密数字”</a> 中所讲，我们可以定义一个与之前变量同名的新变量。Rustacean 们称之为第一个变量被第二个 <strong>隐藏</strong> 了，这意味着程序使用这个变量时会看到第二个值。可以用相同变量名称来隐藏一个变量，以及重复使用 <code>let</code> 关键字来多次隐藏，如下所示：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> x = x + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> x = x * <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The value of x in the inner scope is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序首先将 <code>x</code> 绑定到值 <code>5</code> 上。接着通过 <code>let x =</code> 隐藏 <code>x</code>，获取初始值并加 <code>1</code>，这样 <code>x</code> 的值就变成 <code>6</code> 了。然后，在内部作用域内，第三个 <code>let</code> 语句也隐藏了 <code>x</code>，将之前的值乘以 <code>2</code>，<code>x</code> 得到的值是 <code>12</code>。当该作用域结束时，内部 shadowing 的作用域也结束了，<code>x</code> 又返回到 <code>6</code>。运行这个程序，它会有如下输出：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cargo run</span></span><br><span class="line">   Compiling variables v0.1.0 (file:///projects/variables)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.31s</span><br><span class="line">     Running `target/debug/variables`</span><br><span class="line">The value of x in the inner scope is: 12</span><br><span class="line">The value of x is: 6</span><br></pre></td></tr></table></figure>

<p>隐藏与将变量标记为 <code>mut</code> 是有区别的。当不小心尝试对变量重新赋值时，如果没有使用 <code>let</code> 关键字，就会导致编译时错误。通过使用 <code>let</code>，我们可以用这个值进行一些计算，不过计算完之后变量仍然是不可变的。</p>
<p><code>mut</code> 与隐藏的另一个区别是，当再次使用 <code>let</code> 时，实际上创建了一个新变量，我们可以改变值的类型，但复用这个名字。例如，假设程序请求用户输入空格字符来说明希望在文本之间显示多少个空格，然而我们真正需要的是将输入存储成数字（多少个空格）：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> spaces = <span class="string">&quot;   &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> spaces = spaces.len();</span><br></pre></td></tr></table></figure>

<p>这里允许第一个 <code>spaces</code> 变量是字符串类型，而第二个 <code>spaces</code> 变量，它是一个恰巧与第一个变量同名的崭新变量，是数字类型。隐藏使我们不必使用不同的名字，如 <code>spaces_str</code> 和 <code>spaces_num</code>；相反，我们可以复用 <code>spaces</code> 这个更简单的名字。然而，如果尝试使用 <code>mut</code>，将会得到一个编译时错误，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let mut spaces &#x3D; &quot;   &quot;;</span><br><span class="line">spaces &#x3D; spaces.len();</span><br></pre></td></tr></table></figure>

<p>这个错误说明，我们不能改变变量的类型：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cargo run</span></span><br><span class="line">   Compiling variables v0.1.0 (file:///projects/variables)</span><br><span class="line">error[E0308]: mismatched types</span><br><span class="line"><span class="meta"> --&gt;</span><span class="bash"> src/main.rs:3:14</span></span><br><span class="line">  |</span><br><span class="line">3 |     spaces = spaces.len();</span><br><span class="line">  |              ^^^^^^^^^^^^ expected `&amp;str`, found `usize`</span><br><span class="line"></span><br><span class="line">error: aborting due to previous error</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0308`.</span><br><span class="line">error: could not compile `variables`</span><br><span class="line"></span><br><span class="line">To learn more, run the command again with --verbose.</span><br></pre></td></tr></table></figure>

<p>现在我们已经了解了变量如何工作，让我们看看变量可以拥有的更多数据类型。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Rust/">Rust</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    &copy; 2021 chf007 网站备案/许可证号：<a href="https://beian.miit.gov.cn" target="_blank">粤ICP备17102038号-1</a>
  </p>
</footer>

    
    
  </div>
</div>
</body>
</html>